# ゆるふわアジャイル
### アジャイルソフトウェア開発の奥義 読書会第5回

@siguremon - 2013/07/06

---

## アジャイルの価値

- プロセスやツールよりも、人と人同士の交流を
- 包括的なドキュメントよりも、動作するソフトウェアを
- 契約上の交渉よりも、顧客との協調を
- 計画に従うよりも、変化に対応することを

---

## 前回のまとめ
- TDDでボーリングのスコア計算やってみた

---

## 今回のテーマ
- 第2部 アジャイル設計
  - 第7章 アジャイル設計とは
  - 第8章 単一責任の原則（SRP）


---

 
## 第2部 アジャイル設計
アジャイルではイテレーションごとにシステムの設計に磨きをかけ、
今と同じレベルの質を保てるようにする

--

- 設計の善し悪しってどう判断するの？
 - 悪い設計のパターン＝貧弱な設計の兆候
 - よい設計のパターン＝オブジェクト指向の原則

---

## 第7章 アジャイル設計とは

設計ってなに？

--

設計＝Excel方眼紙？

--

設計＝UML？？

--

設計＝ソースコード！

---

## 7.1 ソフトウェアの何が狂うのか？

--

- ソフトウェア is なまもの
- -> どんどん腐っていきます

--

いわゆる「レガシーコード」「技術的負債」

--

動いているものに触るな！ -> そりゃねーよ

---

## 7.2 設計の悪臭ーー腐敗するソフトウェアの兆候
1. 硬さ
2. もろさ
3. 移植性のなさ
4. 扱いにくさ
5. 不必要な複雑さ
6. 不必要な繰り返し
7. 不透明さ

---

## 硬さ

いわゆる「結合度」

--

あ…ありのまま今起こったことを話すぜ！

ある１行を直そうと思ったら、いつの間にか500行書き換えていた…

な…何を言ってるのかわからねーと思うが、

俺も何をしているのか分からなかった…

--

結合度が高い＝ガッチガチ

---

## もろさ

1つの変更によって他の多くの部分が壊れてしまう

--

バグを修正しました！

--

-> HERE COMES A NEW CHALLENGER!!!

--

-> さらに修正しました！

--

-> HERE COMES A NEW CHALLENGER!!!

--

-> …(:3」∠)_

--

硬い≒もろい？

---

## 移植性のなさ

上司「こないださー、似たような機能作ったじゃん？ちゃちゃっと直してこっちでも使えるようにしてよー設計書も使い回しでさー」

「（その機能はそこでしか使えないわ…）」

---

## 扱いにくさ
- ソフトウェアの扱いにくさ
- 開発環境の扱いにくさ

--

ソフトウェアの扱いにくさ＝黒魔術

--

- 魔術師「ここをビットシフトして…XORとって…」

- SE「日本語でおk」

--

開発環境の扱いにくさ

--

- まず社内独自のIDEをダウンロードしてきます
- ソースコードは今はここのリポジトリを参照してください
- ただし、xxxはこちらのファイルサーバから最新版を…
- yyyは某さんが持っているのでもらって…
- ビルドするためにはコマンド1〜Nまでを手打ちで実行して…
- 作業ごとにチェックリストに印をつけて…

--

.oO（Jenkinsおじさんならボタン一つでぽちっとなのに）

---

## 不必要な複雑さ

```java:
if (x == 6) {
 …
} else {
    if (x == 4) {
        …
    } else {
        if (x == 2) {
            …
        }
```

```java:
if ((x <= 6) && (x & 2 == 0)) {
    …
} else {
    …
}
```

---

## 不必要な繰り返し

- calcXXX_01() {大体同じ処理}
- calcXXX_02() {大体同じ処理}
- calcZZZ_XXX_01() {大体同じ処理}

- calcXXX_01に仕様変更！　=>どこまで直したらいいの...

---

## 不透明さ

```java:java
execute(Map<String, String> input, httprequest req, httpresponse res)  {
	String param1 = input.get("param1");
	if (param1 == "1") {
		execXXX(input, req, res);
	} else if (param2 == "2") {
		execYYY(input, req, res);
	} 
}
```

---

## 7.2.1 何がソフトウェアを腐敗させてしまうのか？

--

仕様変更が悪い？本当に？

--

- 仕様は変更されるもの
- 変更に耐えられる設計
- そのためのプラクティス

---

## 7.2.2 アジャイルチームはソフトウェアの腐敗を許さない

- システム設計を可能な限りクリーンかつシンプルに保つ
- 頻繁にユニットテスト・受け入れテストを行う

---

## 7.3  「コピー」プログラムの例


---

## 7.4 可能な限り美しく設計を保つ

- 設計の「クリーンアップ」
 - 頻繁に実施することで、設計を常にクリーン・シンプル・分かりやすく保つ

---

## 7.5 結論

- アジャイルな設計とは
 - 設計をクリーン・シンプル・分かりやすく保つこと
 - 原則・パターン・プラクティスを継続的に適用すること

---

## 第8章 単一責任の原則（SRP）

---

## 8.1 単一責任の原則

クラスを変更する理由は1つ以上存在してはならない

--

![fig.1](/images/fig1.png)

--
![fig.2](/images/fig2.png)

---

## 8.1.1 役割とは何か？

- 「役割（責任）＝変更理由」
- 役割の数え方はケースバイケース

--

- モデムの場合(p124)
 - 「接続の管理」・「データ通信」の2つ
 - 「モデム」という１つの役割

--


「変更の理由が変更の理由たるのは、実際に変更の理由が生じた場合だけである」

---

## 8.1.2 結合している役割の分離

- 実体クラスでは複数の役割を1つに結合するケースもある（モデム）
 - インターフェースとしては役割を分離
 - 他にそのクラスに依存するものがない
 

---

## 8.1.3 永続性のあるシステムと単一責任の原則

- ビジネスロジックと永続性システムの結合
 - よくある悪いパターン

---

## 8.2 結論

- クラスを変更する理由は1つ以上存在してはならない
 - 正しく適用することが最も難しい原則の1つ

--

- 結合している役割を見つけて分離する作業＝ソフトウェア設計の本質

---

## まとめ

- アジャイルな設計とは
 - 設計（ソースコード）を常にクリーン・シンプル・分かりやすく保つこと
- 腐敗するソフトウェアの兆候
 - 硬さ・もろさ・移植性のなさ・扱いにくさ・不必要な複雑さ・不必要な繰り返し・不透明さ

--

- 単一責任の原則（SRP）
 - クラスを変更する理由は1つ以上存在してはならない
 - 単純だが難しい
 - ソフトウェア設計の本質

